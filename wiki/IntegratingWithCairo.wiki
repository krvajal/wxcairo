#summary Integrating with Cairo

= Windows =

= Platform Independent Rendering to a Buffer =
On platforms such as X11 where the it's currently unknown how to directly use Cairo to render to a DC it is possible to render to an image and then blit that image to screen using a wxBufferedDC.

There are probably more efficient ways of doing this. If there are please make a suggestion. 

{{{

// Allocate a buffer large enough to store the image data. Use malloc()
// instead of new(). Each 
unsigned int image_buffer_len = rect.width * rect.height * 4;
unsigned char* image_buffer = (unsigned char*)malloc(image_buffer_len);

cairo_surface_t* cairo_surface = cairo_image_surface_create_for_data(
                                image_buffer,
                                CAIRO_FORMAT_RGB24,
                                rect.width,
                                rect.height,
                                rect.width * 4);
cairo_t* cairo_image = cairo_create(cairo_surface);

// Render your object here
Render(cairo_image, rect.width, rect.height);

// Now translate the raw image data from the format stored
// by cairo into a format understood by wxImage.
unsigned char* output = (unsigned char*)malloc(image_buffer_len);
int offset = 0;
for(size_t count = 0; count < image_buffer_len; count+=4)
{
    int r = *(image_buffer+count+2);
    *(output + offset) = r;
    offset++;
    int g = *(image_buffer+count+1);
    *(output + offset) = g;
    offset++;
    int b = *(image_buffer+count+0);
    *(output + offset) = b;
    offset++;
} 

// Create a wxImage from the buffer and then a wxBitmap from that
wxImage img(rect.width, rect.height, output, true);
wxBitmap bmp(img);
wxClientDC client_dc(this);

// Create a double buffer to draw the plot
// on screen to prevent flicker from occuring.
wxBufferedDC dc;
dc.Init(&client_dc, bmp);

cairo_destroy(cairo_image);
cairo_surface_destroy(cairo_surface);
free(image_buffer);
free(output);
}}}